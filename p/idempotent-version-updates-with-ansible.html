<!DOCTYPE html>
<html class="h-full">
  <head>
    <title>
      Idempotent version updates with Ansible; Sgoettschkes.me;
    </title>

    <meta charset="utf-8" />
    <meta name="robots" content="index, follow" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />

    <link rel="stylesheet" type="text/css" media="screen" href="//fonts.googleapis.com/css?family=Open+Sans:400,700|Lora:400,700" >
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" media=all href="/css/app.css" />


    <meta name="google-site-verification" content="owr8_sYsogeEj0Ovgy63UTqcNdYayhgQOD611Kcn250" />
  </head>
  <body class="flex flex-col h-full text-black bg-white">
    <header class="flex flex-row h-2/6 min-h-[33%] max-h-[33%] bg-gradient-to-b from-slate-600 to-slate-800">
  <div class="grid items-center w-full grid-cols-1 justify-items-center">
    <div class="text-center text-white h-fit">
      <p class="mb-4 font-serif text-4xl font-bold"><a href="/">Sgoettschkes.me</a></p>
      <p class="font-serif text-xl">Coding 5 to 9</p>
    </div>
  </div>
</header>

    <nav class="pt-4 font-sans text-lg">
  <ul class="mx-auto w-fit">
    <li class="inline pr-12"><a href="/">Home</a></li>
    <li class="inline pr-12"><a href="/about">About</a></li>
    <li class="inline pr-0"><a href="/now">Now</a></li>
  </ul>
</nav>

    <main class="w-3/5 mx-auto my-10 mb-auto">
      
<article class="mb-5">
  <p class="m-0 font-sans text-sm text-gray-400">Written by Sebastian on Feb 29, 2016 in Dev</p>
  <h1 class="mt-2 mb-4 font-serif text-4xl font-bold">Idempotent version updates with Ansible</h1>
  <p>If you are a seasoned Vagrant user, you know the problem around provisioning. If some software version changes, everybody needs to provision his or her machine again. Otherwise, things will fail eventually. You’ll also run into problems if running the provisioning twice fails for some reason (e.g. because a file already exists somewhere).</p><h2>Idempotent setup</h2><p>If you are setting up your provisioning, the first thing you need to make sure is that you can run the setup steps more than once and it works without manual steps in between. Nothing is more frustrating than running <code class="inline">vagrant provision</code> and being left with errors because something is already installed or a file is already at a specific place.</p><p>This is easy to do, even with a basic shell provisioner. You can check for the existence of files and test if some software is already installed. It’s also pretty easy to test: Just run the provisioning again and see if it works. If not, add appropriate tests and not run the offending commands.</p><h2>Updating vs. optimizing</h2><p>Getting the provisioning step to update software to the correct version is more tricky. It’s easy with package managers like composer for PHP or pip for Python where you have a file containing all dependencies and their versions and the package manager takes care of the rest. If you need to download, compile and install a library, you are faced with three very different options: You can do all the steps every time when provisioning, which takes time even though most of the time nothing changed. You can also install it once and then forget about it, which means nothing happens if a new version for a software is available. The third thing is figuring out the current version as well as the target version and only run the steps for installing it if they don’t match.</p><p>With Ansible, the Vagrant provisioner of choice for me, all three ways are possible. It’s important to be clear which one you are choosing so you know what drawbacks your solution might have.</p><p>To run some steps every time, give them no restriction like <code class="inline">creates</code> for commands and Ansible will do as told. If you are using the <code class="inline">command</code> or <code class="inline">shell</code> module, Ansible will run it every time. If your process is downloading some tar or zip and extracting it, maybe running a setup command as well, Ansible will download it every time and you’ll get new versions available under the url.</p><p>If you wanna run the whole process only once , use <code class="inline">creates</code> or similar instructions. Ansible will check if the file or directory is there and if it is, skip the step. As an example, let’s say you download some tar and extract it somewhere. The <code class="inline">unarchive</code> module takes a parameter called <code class="inline">creates</code>. If you set it to the extracted path, the command will do nothing if that folder is already there. As Ansible can’t possible figure out if the version inside the tar is the same as the existing one, it won’t unarchive it even though the version changed.</p><h2>Conditionals</h2><p>If you want to run a command or a set of commands only if the installed version of a software differs from the target version, things are getting interesting. Let me walk you through that scenario. As an example, I’ll use the Dart SDK.</p><p>First, we need a command to get the current version installed. For Dart, that’s reading the <code class="inline">version</code> file which contains only the version string. Other tools might make this more complicated, e.g. the Google Cloud SDK, which prints a lot of information in addition to the version when running <code class="inline">gcloud --version</code>. I usually use some command line magic like <code class="inline">sed</code> or <code class="inline">cut</code> to extract the part I need. Using the <code class="inline">shell</code> module from ansible, I pipe them together to end up with the version being the stdout for that command. We need to use <code class="inline">register</code> to put the output of that task into a variable. The whole task could look like this:</p><pre><code>- name: Read the dart version
  shell: cat /usr/local/lib/dart-sdk/version
  register: current_dart_version
  ignore_errors: True
  changed_when: dart_version != current_dart_version.stdout</code></pre><p>As you can see, I ignore errors because the shell command might fail if dart is not installed. I use <code class="inline">changed_when</code> because I like a clean output from Ansible. You can also see a variable named <code class="inline">dart_version</code> which I did not mention yet. It’s simply a variable keeping the target dart version.</p><p>Next, let us download the Dart SDK if needed:</p><pre><code>- name: download dart sdk
  get_url:
    dest=/tmp/dartsdk.zip
    force=yes
    url=https://storage.googleapis.com/dart-archive/channels/stable/release/{{ dart_version }}/sdk/dartsdk-linux-x64-release.zip
  when: dart_version != current_dart_version.stdout</code></pre><p>Again, we use the <code class="inline">dart_version</code> as a target both in the url and for the <code class="inline">when</code> clause which compares the stdout from the above command with our target. The last step is to extract the zip:</p><pre><code>- name: extract dart sdk
  unarchive:
    copy=no
    dest=/usr/local/lib
    src=/tmp/dartsdk.zip
  when: dart_version != current_dart_version.stdout</code></pre><p>The same pattern repeats here as well. We only run the command if the target version is different from the current one. You can use this pattern for all kinds of installation and steps performed after the installation is done.</p><h2>Getting fail-safe</h2><p>Even though this seems very much all you can want from a provisioning step, if you have to take care of real servers in production, you might want to be even more cautious. In the example above, if some files are not present in the new SDK, they are not deleted as the extract commands does not take care of this. We could work around this by first deleting the SDK.</p><p>In production, it might be valuable to not just replace a version but have two versions installed and switch a symlink or something to change over. This way, it’s not possible that a process has access to the software in an unpredictable state.</p><p>One tip regarding the version extraction: There are different ways to read the version! You might be able to read the version from some version-file or run the command with a <code class="inline">COMMAND --version</code> parameter. Look for different ways and see if some outputs only the exact version. And if you have to, using some regex with <code class="inline">sed</code> might not be the cleanest way but it does the job.</p>
</article>

    </main>
    <footer class="pt-2 pb-4 mt-5 text-sm border-t border-slate-500 bg-gradient-to-b from-slate-200 to-slate-300">
  <div class="flex">
    <div class="flex-none px-4">
      <a href="/feed.xml"><i class="fa-solid fa-rss"></i></a>
    </div>
    <div class="flex-grow text-center">
      <p class="text-xs leading-5">
        &copy; 2014 - 2022
        <a href="/about" class="text-blue">Sebastian Göttschkes</a>
        |
        Hosted by
        <a href="https://pages.github.com/" rel="noopener noreferrer" target="_blank" class="text-blue">GitHub Pages</a>
        |
        Powered by
        <a href="https://stillstatic.io" rel="noopener noreferrer" target="_blank" class="text-blue">Still</a>
      </p>
    </div>
    <div class="flex-none px-3">
      <ul class="">
        <li class="inline mx-1">
          <a href="https://www.facebook.com/sgoettschkes" rel="noopener noreferrer" target="_blank"><i class="fa-brands fa-facebook-f"></i></a>
        </li>
        <li class="inline mx-1">
        <a href="https://twitter.com/Sgoettschkes" rel="noopener noreferrer" target="_blank"><i class="fa-brands fa-twitter"></i></a>
        </li>
        <li class="inline mx-1">
          <a href="https://www.linkedin.com/in/sgoettschkes/" rel="noopener noreferrer" target="_blank"><i class="fa-brands fa-linkedin-in"></i></a>
        </li>
      </ul>
    </div>
  </div>
</footer>

  </body>
</html>
